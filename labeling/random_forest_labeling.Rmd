---
title: "Random Forest Labeling"
output:
  html_document:
    theme: default
    highlight: pygments
    toc: true
    toc_depth: 3
    toc_float: true
editor_options:
  chunk_output_type: console
---
Author: Dan Wexler\
Date: `r Sys.Date()`

This script walks through the process of using an already trained random
forest model for labeling natural disturbance patches. It is divided into
sections that delineate different parts of the process, such as cleaning the
input data, applying the model, and summarizing the results. Below are the
inputs to and outputs of this script.\
INPUTS:\
1) .csv file generated by Google Earth Engine where each row represents a
disturbance polygon and each column is the value of a certain predictor
variable for that polygon.\
2) Trained random forest model that can be used to predict disturbance
labels for polygons.\
3) Table breaking down probability thresholds and omission rates for each
disturbance in the random forest model.\
4) List of variables used in the final random forest model.\
OUTPUTS:\
1) A table containing the unique ids for each disturbance patch, the label
generated by the random forest model, the probability assigned by the model
of that label being a certain disturbance class, and a flag indicating whether
that label should be accepted or rejected, based on the probability.

### (1) Setup
This block of code contains variables that the user can modify to fit their
specific needs. This is the only block of code that requires user input,
barring more involved modification of the script. The in-line comments detail
specifically what each variable represents.
```{r setup 1}
# the path to the file containing the predictor variables
predictors_path <- "C:/Users/dwexler/Desktop/R/Landscape-Disturbance-Classification/training/predictors.csv"
# the path to the file containing the random forest model, should also contain
# a probability table broken down by disturbance and a list of variables
model_path <- "C:/Users/dwexler/Desktop/R/Landscape-Disturbance-Classification/training/best_random_forest"
# the name of the file that will store labels generated by the model
save_name <- "disturbance_labels"
# if TRUE, filter out disturbance patches from the year 1987
drop_1987 <- TRUE
# the number of each disturbance type to be flagged for QA/QC sampling
sample_size <- 50
```

This block of code contains a function for creating tables that will be used
throughout the script.
```{r setp 2}
# function for creating tables
create_table <- function(table,title,rows) {
  DT::datatable(table,class="cell-border stripe hover",
                rownames=rows,caption=title,
                options=list(pageLength=nrow(table),dom="t",
                             order=list(classes="no-sort")))
}
```

Here we load the R libraries that are used throughout the script. Some or all 
of them may have to be downloaded.
```{r setup 3,message=FALSE,warning=FALSE}
# loads R libraries
library(randomForest)
library(DT)
library(dplyr)
```

Now we load and clean the four inputs to this script. These inputs include
a list of variables used in the random forest model, an array of predictor
variables for each disturbance patch, the trained random forest model, and a
table with probability and error metrics for each disturbance type.
```{r setup 4}
# loads the list of variables that the model will use to make classifications
variables <- read.csv(paste(model_path,"_variables.csv",sep=""))[,1]
# loads the predictor variables
predictors <- read.csv(predictors_path)
# filters out patches from the year 1987
if (drop_1987) {
  predictors <- predictors[predictors$yod!=1987,]
}
# extracts a list of unique patch ids
ids <- data.frame(predictors$patch_name)
# filters the predictor variables using the loaded list of variables
predictors <- subset(predictors,select=variables)
# converts the variables to numeric and changes NA values to 0
predictors <- data.frame(sapply(predictors,as.numeric))
predictors[is.na(predictors)] <- 0
# loads the trained random forest model
forest <- readRDS(model_path)
# loads the table containing probability and error metrics for each disturbance
metrics <- read.csv(paste(model_path,"_metrics.csv",sep=""))
disturbances <- metrics[,1]
metrics <- metrics[,c(2,3,4)]
rownames(metrics) <- disturbances
```

### (2) Labeling
We are now ready to apply the random forest model to label disturbance patches.
This block of code feeds the predictor variables through the model, then
analyzes the voting results to determine whether a particular label is
'acceptable'. This acceptability is determine by three criteria. The first is
whether classifications of a certain disturbance type are significant, as
determined by the training script. The second is whether the probability at 
which a classification was made is greater than the probability threshold 
determined in the training script. The third is if the classification 
probability is greater than 1/k, k being the number of disturbance classes.
This represents a majority vote. The result is a table containing the unique
ids for each disturbance patch, the best label generated by the random forest
model, the probability of that classification, and a flag indicating whether
that label should be accepted or rejected. The label, probability, and
acceptance are also displayed for the second best classification. The last
column displays the final classification, based on the first and second best
classifications and their respective acceptances. If the first label is not
acceptable, but the second is, the second label is assigned. If neither the
first nor second label is acceptable, no label is assigned. The first 10 rows 
of the output are shown as an example, with the patch IDs hidden for display.\
\
This code defines a function that checks if a classification is acceptable...
```{r labeling 1}
# a function that checks if a certain classification is acceptable
check_threshold <- function(votes,ind) {
  # gets the disturbance label
  label <- votes[ind,1]
  # gets the probability of classification
  prob <- votes[ind,2]*100
  # gets the probability threshold for the disturbance type
  threshold <- metrics[label,1]
  # finds whether classifications of this disturbance type are significant
  sig <- metrics[label,3]
  # if the probability of classification is greater than the threshold, if
  # classifications of this disturbance type are significant, and if the
  # probability is greater than 1/k where k is the number of disturbances,
  # change the 'accept' flag to 'yes', otherwise 'no'
  accept <- "no"
  if (!is.na(threshold)) {
    if (prob>=threshold & sig=="yes" & prob>=100/length(disturbances)) {
      accept <- "yes"
    } 
  }
  # return the accept flag
  return (accept)
}
```

...and this code uses the function to label the disturbance patches.
```{r labeling 2}
# applies the random forest model and gets voting distributions
predictions <- as.data.frame(predict(forest,predictors,type="prob"))
# creates a data frame to store results
results <- data.frame(matrix(NA,nrow(predictions),7))
results[,1] <- ids
colnames(results) <- c("ID","Label1","Prob1","Accept1","Label2","Prob2","Accept2")
# for each disturbance patch
for (i in 1:nrow(predictions)) {
  # get the voting distribution
  to_sort <- data.frame(Label=disturbances,Errors=as.numeric(predictions[i,]))
  # sort the voting distribution
  sorted <- to_sort[order(to_sort$Errors,decreasing=TRUE),]
  # gets the the disturbance(s) with the highest probabilities
  best_ind <- which(sorted[,2]==max(sorted[,2]))
  next_ind <- 2
  # if there is a tie for most likely disturbance 
  if (length(best_ind)>1) {
    # randomly select between the tied disturbances
    pick <- sample(best_ind,2,replace=FALSE)
    best_ind <- pick[1]
    next_ind <- pick[2]
  }
  # store the results
  results[i,2] <- sorted[best_ind,1]
  results[i,3] <- round(sorted[best_ind,2]*100,2)
  results[i,4] <- check_threshold(sorted,best_ind)
  results[i,5] <- sorted[next_ind,1]
  results[i,6] <- round(sorted[next_ind,2]*100,2)
  results[i,7] <- check_threshold(sorted,next_ind)
}
# displays the labeling results
caption <- "First 10 rows of labeling results (patch IDs are hidden)"
create_table(results[1:10,2:7],caption,FALSE)
```

This block adds a new column to the label array shown above containing a flag
that indicates whether that particular disturbance patch will be a part of the
QAQC process. 50 of each disturbance type are randomly chosen for QAQC. If
there are fewer than 50 of a certain type of disturbance, all of the patches
of that disturbance type are flagged for QAQC.
```{r labeling 3}
# adds a new column for QAQC flags to result array
results$QAQC <- FALSE
# for each disturbance
for (i in 1:length(disturbances)) {
  dist <- disturbances[i]
  # filter the results array by disturbance type
  indices <- which(results$Label1==dist&results$Accept1=="yes")
  # find the number of accepted disturbances
  num_dists <- length(indices)
  # if there are any disturbances of the current type
  if (num_dists>0) {
    samp <- 0
    # if there are fewer than a critical number of disturbances
    if (num_dists < sample_size) {
      # set the sample size equal to the number of disturbances
      samp <- num_dists
    # if there are more than a critical number of disturbances
    } else {
      # set the sample size equal to the user chosen value
      samp <- sample_size
    }
    # flag a random selection of the current disturbance type for QAQC
    rand_indices <- sample(indices,samp,replace=FALSE)
    results[rand_indices,"QAQC"] <- TRUE
  }
}
```

### (3) Saving Results
This section saves the labeled disturbance patches (along with probability and
acceptance information). This file will save to the folder in which the script
is located.
```{r saving results}
# saves the labeled disturbance patches
write.csv(results,file=paste(save_name,".csv",sep=""),row.names=FALSE)
```

### (4) Analysis
This section walks through some light analyses of the labeling results. We look
at the distribution of accepted labels, the disturbance-wise classification
probabilities, and more.
```{r analysis 1}
# creates a data frame to store the results
analysis <- data.frame(matrix(NA,length(disturbances),6))
analysis[,1] <- disturbances
colnames(analysis) <- c("Disturbance","Num Top Label","Avg Top Prob (%)",
                        "Num 2nd Label","Avg 2nd Prob (%)","Total")
# for each disturbance type
for (i in 1:length(disturbances)) {
  dist <- disturbances[i]
  # filter the label results by first choice disturbance type
  best_filtered <- results[which(results$Label1==dist&results$Accept1=="yes"),]
  # filter the label results by second choice disturbance type
  next_filtered <- results[which(results$Label2==dist&results$Accept2=="yes"&results$Accept1=="no"),]
  # if there are patches labeled with the current disturbance type
  if (nrow(best_filtered)!=0) {
    # store data
    analysis[i,2] <- nrow(best_filtered)
    analysis[i,3] <- round(mean(best_filtered$Prob1),2)
    analysis[i,4] <- nrow(next_filtered)
    analysis[i,5] <- round(mean(next_filtered$Prob2),2)
    analysis[i,6] <- nrow(best_filtered)+nrow(next_filtered)
  }
}
# calculates the percent of labels accepted
totl_accepted <- round((sum(analysis[,6],na.rm=TRUE)/nrow(results))*100,2)
best_accepted <- round((sum(analysis[,2],na.rm=TRUE)/nrow(results))*100,2)
next_accepted <- round((sum(analysis[,4],na.rm=TRUE)/nrow(results))*100,2)
```

The following table displays the distribution of the accepted labels, broken
down by primary and secondary label. For each disturbance, the number of
primary and secondary labels of that disturbance type are shown, as well as the
average classification probabilities. The final column is the sum of the second
and fourth columns.\
------------------------------------------------------------------------------\
The percent of disturbance patches classified is: `r totl_accepted`%\
The contribution of primary labels is: `r best_accepted`%\
The contribution of secondary labels is: `r next_accepted`%\
------------------------------------------------------------------------------\
```{r analysis 2}
# displays the table described above
create_table(analysis,"Accepted label breakdown",FALSE)
```

<div class="tocify-extend-page" data-unique="tocify-extend-page" style="height: 0;"></div>
