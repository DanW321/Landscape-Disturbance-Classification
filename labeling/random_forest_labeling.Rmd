---
title: "Random Forest Labeling"
output:
  html_document:
    theme: default
    highlight: pygments
    toc: true
    toc_depth: 3
    toc_float: true
editor_options:
  chunk_output_type: console
---
Author: Dan Wexler\
Date: `r Sys.Date()`

This script walks through the process of using an already trained random
forest model for labeling natural disturbance patches. It is divided into
sections that delineate different parts of the process, such as cleaning the
input data, applying the model, and summarizing the results. Below are the
inputs to and outputs of this script.\
INPUTS:\
1) .csv file generated by Google Earth Engine where each row represents a
disturbance polygon and each column is the value of a certain predictor
variable for that polygon.\
2) Trained random forest model that can be used to predict disturbance
labels for polygons.\
3) Table breaking down probability thresholds and omission rates for each
disturbance in the random forest model.\
4) List of variables used in the final random forest model.\
OUTPUTS:\
1) A table containing the unique ids for each disturbance patch, the label
generated by the random forest model, the probability assigned by the model
of that label being a certain disturbance class, and a flag indicating whether
that label should be accepted or rejected, based on the probability.

### (1) Setup
This block of code contains variables that the user can modify to fit their
specific needs. This is the only block of code that requires user input,
barring more involved modification of the script. The in-line comments detail
specifically what each variable represents.
```{r setup 1}
# the path to the file containing the predictor variables
predictors_path <- "C:/Users/dwexler/Desktop/R/nps-repo/training/predictors.csv"
# the path to the file containing the random forest model, should also contain
# a probability table broken down by disturbance and a list of variables
model_path <- "C:/Users/dwexler/Desktop/R/nps-repo/training/best_random_forest"
# the name of the file that will store labels generated by the model
save_name <- "disturbance_labels"
# if TRUE, filter out disturbance patches from the year 1987
drop_1987 <- TRUE
```

This block of code contains a function for creating tables that will be used
throughout the script.
```{r setp 2}
# function for creating tables
create_table <- function(table,title,rows) {
  DT::datatable(table,class="cell-border stripe hover",
                rownames=rows,caption=title,
                options=list(pageLength=nrow(table),dom="t",
                             order=list(classes="no-sort")))
}
```

Here we load the R libraries that are used throughout the script. Some or all 
of them may have to be downloaded.
```{r setup 3,message=FALSE,warning=FALSE}
# loads R libraries
library(randomForest)
library(DT)
library(dplyr)
```

Now we load and clean the four inputs to this script. These inputs include
a list of variables used in the random forest model, an array of predictor
variables for each disturbance patch, the trained random forest model, and a
table with probability and error metrics for each disturbance type.
```{r setup 4}
# loads the list of variables that the model will use to make classifications
variables <- read.csv(paste(model_path,"_variables.csv",sep=""))[,1]
# loads the predictor variables
predictors <- read.csv(predictors_path)
# filters out patches from the year 1987
if (drop_1987) {
  predictors <- predictors[predictors$yod!=1987,]
}
# extracts a list of unique patch ids
ids <- data.frame(predictors$patch_name)
# filters the predictor variables using the loaded list of variables
predictors <- subset(predictors,select=variables)
# converts the variables to numeric and changes NA values to 0
predictors <- data.frame(sapply(predictors,as.numeric))
predictors[is.na(predictors)] <- 0
# loads the trained random forest model
forest <- readRDS(model_path)
# loads the table containing probability and error metrics for each disturbance
metrics <- read.csv(paste(model_path,"_metrics.csv",sep=""))
disturbances <- metrics[,1]
metrics <- metrics[,c(2,3,4)]
rownames(metrics) <- disturbances
```

### (2) Labeling
We are now ready to apply the random forest model to label disturbance patches.
This block of code feeds the predictor variables through the model, then
analyzes the voting results to determine whether a particular label is
'acceptable'. This acceptability is determine by three criteria. The first is
whether classifications of a certain disturbance type are significant, as
determined by the training script. The second is whether the probability at 
which a classification was made is greater than the probability threshold 
determined in the training script. The third is if the classification 
probability is greater than 1/k, k being the number of disturbance classes.
This represents a majority vote. The result is a table containing the unique
ids for each disturbance patch, the best label generated by the random forest
model, the probability of that classification, and a flag indicating whether
that label should be accepted or rejected. The label, probability, and
acceptance are also displayed for the second best classification. The last
column displays the final classification, based on the first and second best
classifications and their respective acceptances. If the first label is not
acceptable, but the second is, the second label is assigned. If neither the
first nor second label is acceptable, no label is assigned. The first 10 rows 
of the output are shown as an example, with the patch IDs hidden for display.\
\
This code defines a function that checks if a classification is acceptable...
```{r labeling 1}
# a function that checks if a certain classification is acceptable
check_threshold <- function(votes,ind) {
  # gets the disturbance label
  label <- votes[ind,1]
  # gets the probability of classification
  prob <- votes[ind,2]*100
  # gets the probability threshold for the disturbance type
  threshold <- metrics[label,1]
  # finds whether classifications of this disturbance type are significant
  sig <- metrics[label,3]
  # if the probability of classification is greater than the threshold, if
  # classifications of this disturbance type are significant, and if the
  # probability is greater than 1/k where k is the number of disturbances,
  # change the 'accept' flag to 'yes', otherwise 'no'
  accept <- "no"
  if (!is.na(threshold)) {
    if (prob>=threshold & sig=="yes" & prob>=100/length(disturbances)) {
      accept <- "yes"
    } 
  }
  # return the accept flag
  return (accept)
}
```

...and this code uses the function to label the disturbance patches.
```{r labeling 2}
# applies the random forest model and gets voting distributions
predictions <- as.data.frame(predict(forest,predictors,type="prob"))
# creates a data frame to store results
results <- data.frame(matrix(NA,nrow(predictions),8))
results[,1] <- ids
colnames(results) <- c("ID","Label1","Prob1","Accept1","Label2","Prob2","Accept2","Final")
# for each disturbance patch
for (i in 1:nrow(predictions)) {
  # get the voting distribution
  to_sort <- data.frame(Label=disturbances,Errors=as.numeric(predictions[i,]))
  # sort the voting distribution
  sorted <- to_sort[order(to_sort$Errors,decreasing=TRUE),]
  # gets the the disturbance(s) with the highest probabilities
  best_ind <- which(sorted[,2]==max(sorted[,2]))
  next_ind <- 2
  # if there is a tie for most likely disturbance 
  if (length(best_ind)>1) {
    # randomly select between the tied disturbances
    pick <- sample(best_ind,2,replace=FALSE)
    best_ind <- pick[1]
    next_ind <- pick[2]
  }
  # store the results
  results[i,2] <- sorted[best_ind,1]
  results[i,3] <- round(sorted[best_ind,2]*100,2)
  results[i,4] <- check_threshold(sorted,best_ind)
  results[i,5] <- sorted[next_ind,1]
  results[i,6] <- round(sorted[next_ind,2]*100,2)
  results[i,7] <- check_threshold(sorted,next_ind)
  # if the first label is acceptable
  if (results[i,4]=="yes") {
    # set the final label to the first label
    results[i,8] <- results[i,2]
  # if the first label is not acceptable but the second is
  } else if (results[i,7]=="yes") {
    # set the final label to the second label
    results[i,8] <- results[i,5]
  }
}
# displays the labeling results
caption <- "First 10 rows of labeling results (patch IDs are hidden)"
create_table(results[1:10,2:8],caption,FALSE)
```

### (3) Saving Results
This section saves the labeled disturbance patches (along with probability and
acceptance information). This file will save to the folder in which the script
is located.
```{r saving results}
# saves the labeled disturbance patches
write.csv(results,file=paste(save_name,".csv",sep=""),row.names=FALSE)
```

### (4) Analysis
This section walks through some light analyses of the labeling results. We look
at the distribution of accepted labels, the disturbance-wise classification
probabilities, and more.
```{r analysis 1}
analysis <- data.frame(matrix(NA,length(disturbances),6))
analysis[,1] <- disturbances
colnames(analysis) <- c("Disturbance","Num Top Label","Avg Top Prob (%)",
                        "Num 2nd Label","Avg 2nd Prob (%)","Total")
for (i in 1:length(disturbances)) {
  dist <- disturbances[i]
  best_filtered <- results[which(results$Label1==dist&results$Accept1=="yes"),]
  next_filtered <- results[which(results$Final==dist&results$Accept1=="no"),]
  if (nrow(best_filtered)!=0) {
    analysis[i,2] <- nrow(best_filtered)
    analysis[i,3] <- round(mean(best_filtered$Prob1),2)
    analysis[i,4] <- nrow(next_filtered)
    analysis[i,5] <- round(mean(next_filtered$Prob2),2)
    analysis[i,6] <- nrow(best_filtered)+nrow(next_filtered)
  }
}
totl_accepted <- round((sum(analysis[,6],na.rm=TRUE)/nrow(results))*100,2)
best_accepted <- round((sum(analysis[,2],na.rm=TRUE)/nrow(results))*100,2)
next_accepted <- round((sum(analysis[,4],na.rm=TRUE)/nrow(results))*100,2)
```

The following table displays the distribution of the accepted labels, broken
down by primary and secondary label. For each disturbance, the number of
primary and secondary labels of that disturbance type are shown, as well as the
average classification probabilities. The final column is the sum of the second
and fourth columns.\
------------------------------------------------------------------------------\
The percent of disturbance patches classified is: `r totl_accepted`%\
The contribution of primary labels is: `r best_accepted`%\
The contribution of secondary labels is: `r next_accepted`%\
------------------------------------------------------------------------------\
```{r analysis 2}
create_table(analysis,"Accepted label breakdown",FALSE)
```

```{r analysis 3}
# labels <- read.csv("C:/Users/dwexler/Desktop/R/nps-repo/training/labels.csv")
# if (drop_1987) {
#   labels <- labels[labels$yod!=1987,]
# }
# spl <- strsplit(ids[,1],"_")[[1]]
# labels <- mutate(labels,patch_name=paste(spl[1],spl[2],spl[3],spl[4],spl[5],yod,annualID,sep='_'))
# results_sort <- arrange(results,ID)
# labels_sort <- arrange(labels,patch_name)
# results_sort <- results_sort[labels_sort$ChangeType!="",]
# labels_sort <- labels_sort[labels_sort$ChangeType!="",]
# errors <- data.frame(matrix(0,length(disturbances),2))
# errors[,1] <- disturbances
# colnames(errors) <- c("Disturbance","Error")
# for (i in 1:length(disturbances)) {
#   disturbance <- disturbances[i]
#   results_filt <- results_sort[labels_sort$ChangeType==disturbance,]
#   labels_filt <- labels_sort[labels_sort$ChangeType==disturbance,]
#   num <- 0
#   dem <- nrow(labels_filt)
#   for (j in 1:nrow(labels_filt)) {
#     if (results_filt$Label[j]==labels_filt$ChangeType[j]) {
#       num <- num+1
#     }
#   }
#   errors[i,2] <- round((1-(num/dem))*100,2)
# }
# DT::datatable(errors,
#               class="cell-border stripe hover",
#               rownames=FALSE,
#               caption="Classification Errors",
#               extensions='Buttons',
#               options=list(pageLength=nrow(errors),
#                            dom="Bt",
#                            order=list(classes="no-sort"),
#                            buttons=list(list(extend="csv",title="classification_errors"))))
```

<div class="tocify-extend-page" data-unique="tocify-extend-page" style="height: 0;"></div>
